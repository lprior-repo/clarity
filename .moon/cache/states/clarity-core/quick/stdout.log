Diff in /home/lewis/src/clarity/clarity-server/tests/allocator_test.rs:5:
 /// 2. Memory allocation/deallocation works correctly
 /// 3. No panics occur during memory operations
 /// 4. The allocator provides expected performance characteristics
[31m-
(B[m use std::alloc::{GlobalAlloc, Layout, System};
 
 #[cfg(test)]
Diff in /home/lewis/src/clarity/clarity-server/tests/allocator_test.rs:12:
 mod allocator_tests {
[31m-    use super::*;
(B[m[32m+  use super::*;
(B[m 
[31m-    /// Test that basic allocation works without panics
(B[m[31m-    #[test]
(B[m[31m-    fn test_basic_allocation() {
(B[m[31m-        let sizes = vec![1, 8, 16, 32, 64, 128, 256, 512, 1024, 4096];
(B[m[32m+  /// Test that basic allocation works without panics
(B[m[32m+  #[test]
(B[m[32m+  fn test_basic_allocation() {
(B[m[32m+    let sizes = vec![1, 8, 16, 32, 64, 128, 256, 512, 1024, 4096];
(B[m 
[31m-        for size in sizes {
(B[m[31m-            let layout = Layout::from_size_align(size, 8).expect("Invalid layout");
(B[m[31m-            unsafe {
(B[m[31m-                let ptr = System.alloc(layout);
(B[m[31m-                assert!(!ptr.is_null(), "Allocation failed for size {}", size);
(B[m[32m+    for size in sizes {
(B[m[32m+      let layout = Layout::from_size_align(size, 8).expect("Invalid layout");
(B[m[32m+      unsafe {
(B[m[32m+        let ptr = System.alloc(layout);
(B[m[32m+        assert!(!ptr.is_null(), "Allocation failed for size {}", size);
(B[m 
[31m-                if size >= 8 {
(B[m[31m-                    *(ptr as *mut u64) = 0xDEADBEEF;
(B[m[31m-                    assert_eq!(*(ptr as *mut u64), 0xDEADBEEF);
(B[m[31m-                }
(B[m[31m-
(B[m[31m-                System.dealloc(ptr, layout);
(B[m[31m-            }
(B[m[32m+        if size >= 8 {
(B[m[32m+          *(ptr as *mut u64) = 0xDEADBEEF;
(B[m[32m+          assert_eq!(*(ptr as *mut u64), 0xDEADBEEF);
(B[m         }
[32m+
(B[m[32m+        System.dealloc(ptr, layout);
(B[m[32m+      }
(B[m     }
[32m+  }
(B[m 
[31m-    /// Test concurrent allocations (multi-threaded safety)
(B[m[31m-    #[test]
(B[m[31m-    fn test_concurrent_allocations() {
(B[m[31m-        use std::sync::{Arc, Barrier};
(B[m[31m-        use std::thread;
(B[m[32m+  /// Test concurrent allocations (multi-threaded safety)
(B[m[32m+  #[test]
(B[m[32m+  fn test_concurrent_allocations() {
(B[m[32m+    use std::sync::{Arc, Barrier};
(B[m[32m+    use std::thread;
(B[m 
[31m-        let num_threads = 8;
(B[m[31m-        let allocations_per_thread = 100;
(B[m[31m-        let barrier = Arc::new(Barrier::new(num_threads));
(B[m[32m+    let num_threads = 8;
(B[m[32m+    let allocations_per_thread = 100;
(B[m[32m+    let barrier = Arc::new(Barrier::new(num_threads));
(B[m 
[31m-        let handles: Vec<_> = (0..num_threads)
(B[m[31m-            .map(|_| {
(B[m[31m-                let barrier = Arc::clone(&barrier);
(B[m[31m-                thread::spawn(move || {
(B[m[31m-                    barrier.wait();
(B[m[32m+    let handles: Vec<_> = (0..num_threads)
(B[m[32m+      .map(|_| {
(B[m[32m+        let barrier = Arc::clone(&barrier);
(B[m[32m+        thread::spawn(move || {
(B[m[32m+          barrier.wait();
(B[m 
[31m-                    for i in 0..allocations_per_thread {
(B[m[31m-                        let size = (i % 10 + 1) * 128;
(B[m[31m-                        let layout = Layout::from_size_align(size, 8).expect("Invalid layout");
(B[m[32m+          for i in 0..allocations_per_thread {
(B[m[32m+            let size = (i % 10 + 1) * 128;
(B[m[32m+            let layout = Layout::from_size_align(size, 8).expect("Invalid layout");
(B[m 
[31m-                        unsafe {
(B[m[31m-                            let ptr = System.alloc(layout);
(B[m[31m-                            assert!(!ptr.is_null(), "Thread allocation failed");
(B[m[32m+            unsafe {
(B[m[32m+              let ptr = System.alloc(layout);
(B[m[32m+              assert!(!ptr.is_null(), "Thread allocation failed");
(B[m 
[31m-                            if size >= 8 {
(B[m[31m-                                *(ptr as *mut u64) = i as u64;
(B[m[31m-                            }
(B[m[32m+              if size >= 8 {
(B[m[32m+                *(ptr as *mut u64) = i as u64;
(B[m[32m+              }
(B[m 
[31m-                            System.dealloc(ptr, layout);
(B[m[31m-                        }
(B[m[31m-                    }
(B[m[32m+              System.dealloc(ptr, layout);
(B[m[32m+            }
(B[m[32m+          }
(B[m 
[31m-                    true
(B[m[31m-                })
(B[m[31m-            })
(B[m[31m-            .collect();
(B[m[32m+          true
(B[m[32m+        })
(B[m[32m+      })
(B[m[32m+      .collect();
(B[m 
[31m-        for handle in handles {
(B[m[31m-            let result = handle.join();
(B[m[31m-            assert!(result.is_ok(), "Thread panicked");
(B[m[31m-            assert!(result.unwrap(), "Thread returned false");
(B[m[31m-        }
(B[m[32m+    for handle in handles {
(B[m[32m+      let result = handle.join();
(B[m[32m+      assert!(result.is_ok(), "Thread panicked");
(B[m[32m+      assert!(result.unwrap(), "Thread returned false");
(B[m     }
[32m+  }
(B[m 
[31m-    /// Verify allocator performance
(B[m[31m-    #[test]
(B[m[31m-    fn test_allocator_performance() {
(B[m[31m-        let start = std::time::Instant::now();
(B[m[32m+  /// Verify allocator performance
(B[m[32m+  #[test]
(B[m[32m+  fn test_allocator_performance() {
(B[m[32m+    let start = std::time::Instant::now();
(B[m 
[31m-        for _ in 0..1000 {
(B[m[31m-            let layout = Layout::new::<[u8; 256]>();
(B[m[31m-            unsafe {
(B[m[31m-                let ptr = System.alloc(layout);
(B[m[31m-                assert!(!ptr.is_null());
(B[m[31m-                System.dealloc(ptr, layout);
(B[m[31m-            }
(B[m[31m-        }
(B[m[32m+    for _ in 0..1000 {
(B[m[32m+      let layout = Layout::new::<[u8; 256]>();
(B[m[32m+      unsafe {
(B[m[32m+        let ptr = System.alloc(layout);
(B[m[32m+        assert!(!ptr.is_null());
(B[m[32m+        System.dealloc(ptr, layout);
(B[m[32m+      }
(B[m[32m+    }
(B[m 
[31m-        let duration = start.elapsed();
(B[m[32m+    let duration = start.elapsed();
(B[m 
[31m-        // With mimalloc, 1000 allocations should be very fast
(B[m[31m-        assert!(
(B[m[31m-            duration.as_millis() < 100,
(B[m[31m-            "Allocator seems slower than expected: {:?}",
(B[m[31m-            duration
(B[m[31m-        );
(B[m[31m-    }
(B[m[32m+    // With mimalloc, 1000 allocations should be very fast
(B[m[32m+    assert!(
(B[m[32m+      duration.as_millis() < 100,
(B[m[32m+      "Allocator seems slower than expected: {:?}",
(B[m[32m+      duration
(B[m[32m+    );
(B[m[32m+  }
(B[m }
 